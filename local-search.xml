<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6-s081-lab8-Lock</title>
    <link href="/2023/03/31/6-s081-lab8-Lock/"/>
    <url>/2023/03/31/6-s081-lab8-Lock/</url>
    
    <content type="html"><![CDATA[<p><img src="/../picture/6.s081lab8lock/star.jpg" alt="换换口味，来个白金之星"></p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-s081-lab6-Multithreading</title>
    <link href="/2023/03/31/6-s081-lab6-Multithreading/"/>
    <url>/2023/03/31/6-s081-lab6-Multithreading/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-s081-lab4-Traps</title>
    <link href="/2023/03/31/6-s081-lab4-Traps/"/>
    <url>/2023/03/31/6-s081-lab4-Traps/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-s081-lab9-File-System</title>
    <link href="/2023/03/29/6-s081-lab9-File-System/"/>
    <url>/2023/03/29/6-s081-lab9-File-System/</url>
    
    <content type="html"><![CDATA[<p><img src="/../picture/6.s081lab9fs/takagi.jpg" alt="镇楼"></p><h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><p>为什么这篇在其他实验之前呢，因为在这个实验上卡了挺长时间，现在做完正好一口气稍微整理下。其他实验可能看完xv6 book几个小时就搞定了，这个反复看了两遍xv6 book加上看了好久的源码才下手来做，趁着做完赶紧记录下来。顺便新建之前几个lab的文件夹，有时间再往里面填。</p><h2 id="文件系统简介（粗略讲讲）"><a href="#文件系统简介（粗略讲讲）" class="headerlink" title="文件系统简介（粗略讲讲）"></a>文件系统简介（粗略讲讲）</h2><p><img src="/../picture/6.s081lab9fs/fs_layout.png" alt="layout of file system"><br>文件系统大概分这些层，xv6 book大概就是按照自底向上的顺序来介绍。<br>首先是disk，xv6的实验用了virtio模拟了一个磁盘，接口就是按块读写的接口<br>然后是Buffer cache，这是非常重要的一个结构，通常来说从disk上读的数据都要放到这里，然后再去进一步被使用。在这个实验里buf的大小和block的大小是相同的，不知道别的文件系统设计里是否会不同。buffer cache的主要目的是同步对磁盘的读写，一次只让一个线程用这个文件的内容<br>接下来是logging layer（感觉这一层很神奇）。这一层主要的目的就是为了崩溃恢复，这里的崩溃恢复主要指的是在write的过程中，当crash发生后，可能会导致一个inode指向已经free的节点，或是一个已经是allocated但是实际上并没有被使用的block。这里我最开始其实理解有一些偏差，xv6中的logging实现方法是完全记录下整个被修改块，也即block&#x2F;buffer本身，当这些积攒到一定数量后再整体落盘，这样就能确定这些操作都是原子性的，如果落盘成功，那么就算崩溃了也能还原，如果不成功，那么就当没有过这些操作，通过这样的手段，就能够保证系统层面的一致性，防止后续运行出错。<br>再然后是inode layer，这个应该非常熟悉了，文件系统用inode记录文件或者目录的属性，两者的区别就是文件在block里存文件数据，目录在block里存目录条目dirent，这个条目再指向下一个inode<br><img src="/../picture/6.s081lab9fs/inode.png" alt="这个图就是很经典的inode的结构图"><br>之后是directory layer，因为实现和文件的inode很像，这里就暂时先跳过了<br>最后就是File descriptor layer，这一层向外暴露出了文件系统的接口，所以文件系统才能方便地使用。每个文件在这个系统里都用结构体struct file来表示。每个进程有一个自己的已经打开的文件的table，而且所有的已经打开的文件在系统中有一个全局的ftable。<br>这部分内容非常多，反复看了xv6 book中的这个章节加代码才有点了解，但是感觉很多细节还是理解不够或是记不住，后面有时间再看一下。</p><h2 id="Large-Files"><a href="#Large-Files" class="headerlink" title="Large Files"></a>Large Files</h2><p>这个实验的目的是提高xv6最大文件的大小。因为现在只有一个indirect节点，所以一个文件最多只有268个block，这在很多情况下不够用。这个实验里再把一个direct block number改成doubly-indirect block，这样能提高到65803个block。<br>这个lab主要需要修改的就是bmap()和itrunc()，这两个函数的作用是遍历文件和销毁文件，所以修改了inode结构之后这两个函数也要相应地变化。这个lab不难，但是有个地方不小心写了一个不太容易察觉的bug，最后查了一下午才找到。<br>稍微修改下定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIRECT 11</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT2 NINDIRECT*NINDIRECT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NINDIRECT2)</span><br></code></pre></td></tr></table></figure><p>因为NDIRECT变了，所以inode和dinode要改成<code>uint addrs[NDIRECT+2];</code><br>bmap里面前半部分不用动，后半部分加一下两层映射的东西，这个也是仿照前面的内容写就可以了，比较简单。这里最开始<code>(addr = a[bn/NINDIRECT])==0</code>写成了<code>addr = a[bn/NINDIRECT]==0</code>所以一直出错，最后一句句对照才找到问题。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">bn -= NINDIRECT;<br>  <span class="hljs-comment">//printf(&quot;finish 2\n&quot;);</span><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT2)&#123;<br>    <span class="hljs-comment">//printf(&quot;in 3\n&quot;);</span><br>    <span class="hljs-comment">//这最开始还抄错了</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>((addr = ip-&gt;</span>addrs[NDIRECT+<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">//printf(&quot;step1\n&quot;);</span><br>      <span class="hljs-function"><span class="hljs-title">ip</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">addrs</span>[NDIRECT+1] = addr = balloc(ip-&gt;</span>dev);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">bp</span> = bread(ip-&gt;</span>dev, addr);<br>    <span class="hljs-comment">//printf(&quot;in double&quot;);</span><br>    <span class="hljs-function"><span class="hljs-title">a</span> = (uint*)bp-&gt;</span><span class="hljs-keyword">data</span>;<br>    <span class="hljs-comment">//等号写错位置了，写代码20分钟debug两个小时，人晕了。。</span><br>    <span class="hljs-keyword">if</span>((addr = a[bn/NINDIRECT])==<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">//printf(&quot;step2\n&quot;);</span><br>      <span class="hljs-function"><span class="hljs-title">a</span>[bn/NINDIRECT] = addr = balloc(ip-&gt;</span>dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-function"><span class="hljs-title">bp</span> = bread(ip-&gt;</span>dev, addr);<br>    <span class="hljs-function"><span class="hljs-title">a</span> = (uint*)bp-&gt;</span><span class="hljs-keyword">data</span>;<br>    <span class="hljs-keyword">if</span>((addr = a[bn%NINDIRECT])==<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">//printf(&quot;step3\n&quot;);</span><br>      <span class="hljs-function"><span class="hljs-title">a</span>[bn%NINDIRECT] = addr = balloc(ip-&gt;</span>dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    return addr;<br>  &#125;<br></code></pre></td></tr></table></figure><p>itruc和bmap几乎是一样的，注意细节就可以了。bread之后记得brelse</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">if</span>(ip-&gt;</span>addrs[NDIRECT+<span class="hljs-number">1</span>])&#123;<br>    <span class="hljs-comment">//这里漏了+1</span><br>    <span class="hljs-function"><span class="hljs-title">bp</span> = bread(ip-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>, ip-&gt;</span>addrs[NDIRECT+<span class="hljs-number">1</span>]);<br>    <span class="hljs-function"><span class="hljs-title">a</span> = (uint*)bp-&gt;</span><span class="hljs-keyword">data</span>;<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; NINDIRECT; k++)&#123;<br>      <span class="hljs-keyword">if</span>(a[k])&#123;<br>        <span class="hljs-function"><span class="hljs-title">bp_in_loop</span> = bread(ip-&gt;</span>dev, a[k]);<br>        <span class="hljs-function"><span class="hljs-title">b</span> = (uint *)bp_in_loop-&gt;</span><span class="hljs-keyword">data</span>;<br>        <span class="hljs-keyword">for</span>(l = <span class="hljs-number">0</span>;l&lt;NINDIRECT;l++)&#123;<br>          <span class="hljs-keyword">if</span>(b[l])&#123;<br>            <span class="hljs-function"><span class="hljs-title">bfree</span>(ip-&gt;</span>dev, b[l]);<br>            <span class="hljs-comment">//b[l]=0;</span><br>          &#125;<br>        &#125;<br>        brelse(bp_in_loop);<br>        <span class="hljs-function"><span class="hljs-title">bfree</span>(ip-&gt;</span>dev, a[k]);<br>        <span class="hljs-comment">//a[k]=0;</span><br>      &#125;<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-function"><span class="hljs-title">bfree</span>(ip-&gt;</span><span class="hljs-function"><span class="hljs-title">dev</span>, ip-&gt;</span>addrs[NDIRECT+<span class="hljs-number">1</span>]);<br>    <span class="hljs-function"><span class="hljs-title">ip</span>-&gt;</span>addrs[NDIRECT+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这个实验总体还是非常简单的，就是细节比较多，有可能在细节上出问题</p><h2 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h2><p>这个实验的目的是加符号链接（也即软链接），通常所说的硬链接，是指一个新的文件指向旧的文件的inode，这个方法有一定局限性，如果inode在另一个设备上就无法链接。而软链接是把要链接的目标的路径保存在软链接文件里，打开软链接文件时通过这个路径递归打开指向的文件。<br>加系统调用应该轻车熟路了，这里就不赘述了，主要讲讲sym_link()怎么实现，以及open里该实现什么功能。<br>参考别的系统调用，可以直接create一个T_SYMLINK类型的文件，然后用writei往第一个数据块写入链接的路径。这里最开始没想明白直接存到文件里，还以为要从inode里找地方，后来发现inode牵扯太多重读了xv6 book这一章才大概想明白怎么做。create返回的inode带锁，所以write完之后需要unlockput，不然单线程测试的时候会因为锁争用一直卡在这里。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">uint64 sys<span class="hljs-constructor">_symlink(<span class="hljs-params">void</span>)</span>&#123;<br>  <span class="hljs-built_in">char</span> target<span class="hljs-literal">[<span class="hljs-number">64</span>]</span>, path<span class="hljs-literal">[<span class="hljs-number">64</span>]</span>;<br>  <span class="hljs-keyword">struct</span> inode *ip;<br>  <span class="hljs-built_in">int</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((n = argstr(<span class="hljs-number">0</span>, target, <span class="hljs-number">64</span>)) &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>argstr(<span class="hljs-number">1</span>, path, <span class="hljs-number">64</span>) &lt; <span class="hljs-number">0</span>)<br>    return -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">begin</span><span class="hljs-constructor">_op()</span>;<br>  <span class="hljs-keyword">if</span>((ip=create(path,T_SYMLINK,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">end</span><span class="hljs-constructor">_op()</span>;<br>    return -<span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(writei(ip,<span class="hljs-number">0</span>,(uint64)target,<span class="hljs-number">0</span>,n)&lt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">end</span><span class="hljs-constructor">_op()</span>;<br>    return -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">//这里最开始没注意到create后的东西是有lock的，所以单线程的时候这里不释放会卡到后面的操作</span><br>  iunlockput(ip);<br>  <span class="hljs-keyword">end</span><span class="hljs-constructor">_op()</span>;<br>  return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>open函数里需要加上文件为软链接文件的情况，大体分为两种：</p><ul><li>正常情况下，打开一个软链接文件时，应该递归打开软链接文件里保存的路径，直到打开一个其他类型的文件</li><li>如果open的参数指定了O_NOFOLLOW，那就不递归，直接返回软链接文件本身，也就是返回的文件描述符指向的文件的inode就是软链接文件的inode<br>所以设计思路就是一个大循环，判断inode是不是T_SYMLINK类型，同时计数，计数超过十失败，如果指定了O_NOFOLLOW就直接break。除此之外就是递归找下一个链接文件的部分，先用readi读出路径，然后namei找到对应的inode，进入下一次循环。这个环节中记得加锁和释放锁，不然多线程测试会出错。<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(ip-&gt;type == T_SYMLINK)&#123;<br>  <span class="hljs-keyword">count</span>++;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span>&gt;<span class="hljs-number">10</span>)&#123;<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(omode &amp; O_NOFOLLOW)&#123;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    readi(ip,<span class="hljs-number">0</span>,(uint64)path,<span class="hljs-number">0</span>,MAXPATH);<br>    iunlockput(ip);<br>    <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">//这里最开始随便加了，看到panic unlock才想明白这里代表没有分配inode，当然是不能直接unlock的</span><br>      <span class="hljs-comment">//iunlockput(ip);</span><br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    ilock(ip);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这个实验代码量虽然不多，但是通读指导书以及理解每个函数的作用用的时间还是挺久的，断断续续做了差不多两周吧。感觉这个实验是挺有意思的一个实验。到这里部分想做的实验差不多做完了，虽然有些没做但是也不太想搞了，后续如果有想再做一下的实验可能会回来看一下，总的来说感觉xv6的实验设计还是挺用心的，系统也挺适合初学者来学习的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读 The Design and Implementation of a Log-Structured File System</title>
    <link href="/2023/03/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-The-Design-and-Implementation-of-a-Log-Structured-File-System/"/>
    <url>/2023/03/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-The-Design-and-Implementation-of-a-Log-Structured-File-System/</url>
    
    <content type="html"><![CDATA[<p><img src="/../picture/LFS-Reading/takagi.jpg" alt="可可爱爱三人组"></p><h1 id="The-Design-and-Implementation-of-a-Log-Structured-File-System"><a href="#The-Design-and-Implementation-of-a-Log-Structured-File-System" class="headerlink" title="The Design and Implementation of a Log-Structured File System"></a>The Design and Implementation of a Log-Structured File System</h1><p>网上的关于LFS的资料有点松散了，看到最后感觉还是得追根溯源来看看这篇论文</p><h2 id="看到一半的中途更新"><a href="#看到一半的中途更新" class="headerlink" title="看到一半的中途更新"></a>看到一半的中途更新</h2><p>这篇论文虽然是我目前找到的几乎可以说是最久远的文献了，但是很多地方介绍的不是非常详细，对于初学者来说不是很友好，前段时间偶然间看到了一篇很不错的文章：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/file-lfs.pdf">https://pages.cs.wisc.edu/~remzi/OSTEP/file-lfs.pdf</a><br>这个文章对于整体结构的描述非常详细，结合着来看这篇文章感觉收获很大！</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>Log-structured file systems are based on the assumption that files are cached in main memory and that increasing memory sizes will make the caches more and more effective at satisfying read requests[1]. As a result, disk traffic will become dominated by writes.</p></blockquote><p>这个文章是基于这样一种假设：如果cache够大，那么所有读请求都会被cache满足，那么硬盘层面的访问延迟就都会出现在写请求上。从现在的角度来看，SSD访问的延迟方面写延迟是远高于读延迟的，也就是说为了满足SSD的访问需要，通过这种方式构建文件系统减少随机写也是合理的。这篇文章就提出了这样的一个文件系统，叫做Sprite LFS <del>雪碧日志文件系统</del></p><h2 id="Design-for-file-systems-of-the-1990’s"><a href="#Design-for-file-systems-of-the-1990’s" class="headerlink" title="Design for file systems of the 1990’s"></a>Design for file systems of the 1990’s</h2><p>其实这段就是背景介绍</p><h3 id="2-1-Technology"><a href="#2-1-Technology" class="headerlink" title="2.1 Technology"></a>2.1 Technology</h3><p>三个部分对文件系统设计非常重要：processors,disks,main memory.</p><ul><li><p>Processors增速太快，导致其他部分必须尽力够得上它的增长速度。</p></li><li><p>Disk也在快速发展，但是发展主要在cost和capacity上，而不是性能上。Disk performance分为两部分，transfer bandwidth和access time。</p><blockquote><p>Disk transfer bandwidth can be improved substantially with the use of disk arrays and parallel-head disks[5] but no major improvements seem likely for access time (it is determined by mechanical motions that are hard to improve). If an application causes a sequence of small disk transfers separated by seeks, then the application is not likely to experience much speedup over the next ten years, even with faster processors.</p></blockquote></li><li><p>main memory的容量在指数级增长，这导致可以使用更大的file cache</p><blockquote><p>First, larger file caches alter the workload presented to the disk by absorbing a greater fraction of the read requests[1, 6]. Most write requests must eventually be reflected on disk for safety, so disk traffic (and disk performance) will become more and more dominated by writes.</p></blockquote></li></ul><p>这点就跟上面提到的一样，cache大了对read利好，这样performance就很大程度上依赖于write了</p><blockquote><p>The second impact of large file caches is that they can serve as write buffers where large numbers of modified blocks can be collected before writing any of them to disk. Buffering may make it possible to write the blocks more efficiently, for example by writing them all in a single sequential transfer with only one seek.</p></blockquote><p>第二点就是可以把多个写请求汇总到一个write buffer里，这样能够减少写的访问磁盘的次数</p><h3 id="2-2-Workloads"><a href="#2-2-Workloads" class="headerlink" title="2.2 Workloads"></a>2.2 Workloads</h3><p>工作负载有两种，小的增删改的场景是LFS的优化场景，大文件的这里提到更侧重硬件方面的设计，但是LFS在大文件上表现也很好</p><blockquote><p>Small files usually result in small random disk I&#x2F;Os, and the creation and deletion times for such files are often dominated by updates to file system ‘‘metadata’’ (the data structures used to locate the attributes and blocks of the file).</p></blockquote><p>小文件增删的时间通常是由metadata(我觉得应该包含创建inode，把inode加到全局表，大概就这两个吧)决定的</p><h3 id="2-3-Problems-with-existing-file-systems"><a href="#2-3-Problems-with-existing-file-systems" class="headerlink" title="2.3 Problems with existing file systems"></a>2.3 Problems with existing file systems</h3><ul><li>以Unix FFS为例，每次创建文件的时候需要访问两次文件属性，文件数据、目录数据和目录属性又需要分别访问一次磁盘。在这样的系统写小文件的时候只有少于5%的磁盘带宽被使用了，其他时间都在寻道。</li><li>现有的文件系统尝试去同步地写（这里没太看懂，为了一致性不是必须要这样吗？看后面怎么解释了）：应用等待写完成，而不是把写挂在后台完成。</li></ul><p>看到这里感觉这个motivation讲的还是挺明确的，就是为了解决small size write的问题。</p><h2 id="Log-structured-file-systems"><a href="#Log-structured-file-systems" class="headerlink" title="Log-structured file systems"></a>Log-structured file systems</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-s081-lab3 Page Table</title>
    <link href="/2023/03/24/6-s081-lab3-Page-Table/"/>
    <url>/2023/03/24/6-s081-lab3-Page-Table/</url>
    
    <content type="html"><![CDATA[<p><img src="/../picture/6.s081lab3/takagi.jpg" alt="高木镇楼(什么时候我能自己画出这样的画就好了)"></p><h1 id="Page-Table"><a href="#Page-Table" class="headerlink" title="Page Table"></a>Page Table</h1>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客配置</title>
    <link href="/2023/03/24/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/03/24/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>这是第一次写博客，也是第一次用hexo，很多东西都不会，最开始写下第一个博客的时候就是按照教程一步一步来的，这个博客权当作一份备忘录，记录下一些hexo相关的东西，留着后面回来查阅</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>hexo n “title” 新建博客<br>hexo g (generate)生成博客<br>hexo s 部署到localhost上<br>hexo d (deploy)部署到远程上，这里绑定的是github.io，所以直接传到github上</p><h2 id="theme"><a href="#theme" class="headerlink" title="theme"></a>theme</h2><p>最开始用的是一个叫melody的模板，但是发现好像有一段时间没更新？而且有点丑，需要自己配的东西有点多<br>后来在github上找了一个能看得过去的模板，这个是链接：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>记录下每个tag颜色的配置方法，方便后面回来查</p><div class="note note-primary">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-secondary">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-danger">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-warning">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-info">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-light">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><p>未完待续……</p>]]></content>
    
    
    
    <tags>
      
      <tag>casual</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-s081-lab2 System call</title>
    <link href="/2023/03/24/6-s081-lab2/"/>
    <url>/2023/03/24/6-s081-lab2/</url>
    
    <content type="html"><![CDATA[<p><img src="/../picture/6.s081lab2/pic2.jpg" alt="高木镇楼"></p><h1 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h1><p>上个实验做了几个用户态的调用，这个实验就要开始尝试做系统调用（system call）</p><h2 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h2><p>trace能够接受一个参数，<strong>mask</strong>，这个参数指定需要去trace哪个或者说哪几个系统调用，输出的格式是</p><blockquote><p>pid: name of system call -&gt; return value</p></blockquote><p>另外trace也能追踪调用它的进程的子进程。<br>上面是要求，接下来就是详细的做法，首先观察输出样例：<br><img src="/../picture/6.s081lab2/p1.png" alt="输出样例"><br>第一个用例只trace了read，第二个把31个低位都设置了，第三个调用trace，第四个trace了fork。接下来根据他给的提示来一步步做就可以了</p><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>往makefile加trace这一项</p><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>接下来需要向user&#x2F;user.h,user&#x2F;usys.pl,kernel&#x2F;syscall.h这几个文件里面加东西，仿照原有的代码就可以，这几步的作用就是usys.pl会在make的时候生成usys.S文件，这里看pl文件里的代码就能看到，就是把调用函数编号放到寄存器里然后调用ecall。那么这一步之后，在调用trace的时候，（通过一些很神奇的汇编层面的东西，这里我暂时也解释的不太清楚，感觉就是把函数的定义用汇编写了出来）就会跳到生成的汇编代码里</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.global <span class="hljs-built_in">trace</span><br><span class="hljs-built_in">trace</span>:<br> <span class="hljs-built_in">li</span> a7, SYS_trace<br> ecall<br> ret<br></code></pre></td></tr></table></figure><p>然后因为定义了SYS_trace，所以这一步是能够通过编译的，但是实际执行的时候，因为找不到真的系统调用，所以执行的时候还是会失败。</p><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p>这时候就需要把实现加进来，在kernel&#x2F;sysproc.c文件里加sys_trace()函数，这个函数在proc结构体里保存调用的参数。所以首先先去kernel&#x2F;proc.h在proc的结构体里加一个<code>int mask</code>。然后在kernel&#x2F;sysproc.c里加上sys_trace的定义</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">uint64</span> sys_trace(<span class="hljs-built_in">void</span>)&#123;<br>  <span class="hljs-built_in">int</span> mask_;<br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>,&amp;mask_)&lt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  myproc()-&gt;mask=mask_;<br>  <span class="hljs-comment">//printf(&quot;mask %d\n&quot;, mask_);</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>提示里面有说syscall.c找得到参数的代码，另外参考上下文中的系统调用，也可以猜出来可以用argint函数，然后把得到的参数放到结构体里。<br>为什么这里参数只能用这样的方式得到呢？我现在的理解是：因为这里是系统调用，涉及到用户态和内核态的切换，参数是传不进来的，这也是为什么sysproc.c里面定义的系统调用都是uint64 xxxx(void)。这里的参数都需要从进程的trapframe上得到。</p><h3 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h3><p>因为还需要调用子进程，去kernel&#x2F;proc.c里面，可以找到copy进程的代码，把<code>np-&gt;mask = p-&gt;mask;</code>也加到里面。这里有一个小小的问题当时写的时候没有想到，就是既然是copy，那么说明默认应该是有值的，结合判定机制，可以猜测应该要初始化成0，但是当时没有注意到，提示里也没有说。这里用到了c语言结构体默认初始化的设置，默认把mask初始化成0了。</p><h3 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h3><p>最后，我们还需要修改一点别的地方的代码。查看kernel&#x2F;syscall.c文件中的void syscall(void)函数，每次ecall调用trap的时候，会调用syscall函数，这个函数首先从a7中得到系统调用编号（因为在usys.pl里把编号放到了a7里面）。然后有一句很重要的话<br><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code><br>这句话的作用是：从上面的syscalls数组里，找到num编号对应的系统调用，调用它，然后把返回值放到a0里。也就是说，这里是唯一能接触到所有系统调用的地方，也是想要实现trace必须修改的地方。这里的实现方法就是判断1&lt;&lt;num和p-&gt;mask有没有交集，如果有交集的话，就说明这个系统调用是需要去trace的，那么就应该输出。所以接下来的修改就很简单了，加上一个包含所有系统调用名字的数组，每次判定trace成功的时候输出pid，sys_call_name_，以及a0</p><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>这个实验需要加一个系统调用，sysinfo，收集当前正在运行的系统的相关数据。系统调用的参数是一个指向struct sysinfo的指针，kernel在调用这个系统调用的时候把内存中空闲字节的数量和state<strong>不是</strong>UNUSED的进程数量（也就是在用的进程数量）</p><h3 id="step1-1"><a href="#step1-1" class="headerlink" title="step1"></a>step1</h3><p>在makefile加 $U&#x2F;_sysinfotest</p><h3 id="step2-1"><a href="#step2-1" class="headerlink" title="step2"></a>step2</h3><p>仿照上面添加系统调用的流程，加上系统调用的接口，需要注意的一点是用户态的调用接口user&#x2F;user.h中声明的<code>int sysinfo(struct sysinfo *)</code>前面需要声明sysinfo结构体。如果到这里添加正确，那么可以正确编译，但是不能顺利执行系统调用（当然不能，因为这里还是空的）</p><h3 id="step3-1"><a href="#step3-1" class="headerlink" title="step3"></a>step3</h3><p>接下来分别实现两个函数，在kernel&#x2F;kalloc.c中实现<code>count_mem()</code>函数统计空闲内存的数量，在kernel&#x2F;proc.c中实现<code>count_proc()</code>函数统计在用的进程数量<br>仿照kalloc.c中的函数实现<code>count_mem()</code>，加锁，然后遍历freelist，计算这个链表的数量，然后解锁，返回数量，这个数量需要乘PGSIZE（这个是测试的时候发现的，指导书没咋说）<br>仿照proc.c中的函数实现<code>count_proc()</code>，遍历proc数组，每次加锁判断状态，如果不是UNUSED(这里最开始写的时候没注意到不是)，就加一，然后解锁，最后返回数量</p><h3 id="step4-1"><a href="#step4-1" class="headerlink" title="step4"></a>step4</h3><p>完成sys_sysinfo函数。这里因为用户态的调用输入的是一个指针，所以参数是最后结果的sysinfo的地址，仿照其他的系统调用的输入方法。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">if</span>(arg<span class="hljs-meta">addr</span>(0,<span class="hljs-variable">&amp;address_sysinfo</span>)&lt;0)&#123;<br>    <span class="hljs-keyword">return</span> -1;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后分别调用<code>count_proc()</code>和<code>count_mem()</code>，把这两个结果存到一个临时的sysinfo中，最后用copyout方法，把这个结果从内核态放到用户态的地址上，得到最后的结果！</p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081-lab1 Util</title>
    <link href="/2023/03/14/6-s081-lab1/"/>
    <url>/2023/03/14/6-s081-lab1/</url>
    
    <content type="html"><![CDATA[<p><img src="/../picture/6.s081lab1/takagi-1.jpg"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先要说的是配置部分，其实整个lab的配置还是挺简单的，用的时间不是很多，我是在windows上做的，因为游戏本上之前装的虚拟机给我留下了很不好的印象，现在秉承着简便易用的原则我最开始就想尝试下能不能在wsl上搞<br>wsl安装随便搜搜就能找到，值得注意的是在Microsoft Store中安装的ubuntu版本需要是20.04，因为这个实验需要用到的riscv的一些库好像只支持这个版本，我最开始没仔细看安装的22.04，然后果不其然失败了，然后卸载重装。结果卸载还没卸载干净，还去查了查原因，用了个什么指令才搞好。<br>安装完就很简单了。指导书说可以直接在文件夹路径输入 \wsl$\ 进入根目录，我的电脑上还装了22.04，所以后面还有一项 \wsl$\Ubuntu-20.04\<br>上面这种方案虽然是网站上给出的，但是一个问题是用不了vscode的c&#x2F;c++插件（因为插件没有安装到wsl的环境中去），所以可以先安装个wsl插件，然后在wsl里切到xv6的文件下然后输入<code>code .</code>，这样就会自动建立wsl与vscode之间的连接，最后在wsl的环境里再安装下c&#x2F;c++插件，这样就能使用跳转功能了<br>安装完简简单单换个源，然后装下依赖，make qemu成功就能开始写代码啦！<br>本来其实是想在win11的终端界面用vim写的，但是他自带的vim切多窗口费劲以及回车不自动对齐等用起来很恶心的功能成功地在我写完第一个实验之后就把我劝退了。（话说最开始我还想多坚持一段时间还很用心地改了终端的默认配色来着）后面就是用vscode打开文件夹直接编辑代码了……<br>还有一件很神奇的事情，因为这个project提供的代码仓库没有主分支，只有每个实验对应的分支，所以只会有一个默认的分支，每次只有在向默认分支推送代码的时候才会算github的contribution。这就导致commit代码但是github上的contribution图没有变化。。。有点难定</p><h2 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h2><p>第一个实验就是非常经典的util实验了，这个跟我当时做的基本是一样的，但是说实话，现在我在写这个blog的时候刚写完lab4的一部分，但是我觉得我用在实验一的时间是最长的，而且还有一些东西没太搞懂</p><h2 id="Sleep-easy"><a href="#Sleep-easy" class="headerlink" title="Sleep(easy)"></a>Sleep(easy)</h2><h2 id="PingPong-easy"><a href="#PingPong-easy" class="headerlink" title="PingPong(easy)"></a>PingPong(easy)</h2><h2 id="Primes-moderate-x2F-hard"><a href="#Primes-moderate-x2F-hard" class="headerlink" title="Primes(moderate&#x2F;hard)"></a>Primes(moderate&#x2F;hard)</h2><h2 id="Find-moderate"><a href="#Find-moderate" class="headerlink" title="Find(moderate)"></a>Find(moderate)</h2><h2 id="Xargs-moderate"><a href="#Xargs-moderate" class="headerlink" title="Xargs(moderate)"></a>Xargs(moderate)</h2><p>未完待续。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Project(开新坑)</title>
    <link href="/2023/03/13/OS-Project/"/>
    <url>/2023/03/13/OS-Project/</url>
    
    <content type="html"><![CDATA[<p>从大四到研究生入学以来研究方向一直没定下来，大概就是之前没有特别想做的方向，加上大四一直比较摸鱼，所以迟迟没有定下想做的领域，研究工作现在也只是浮于表面。最近想开始往文件系统方向转一转，感觉这个方向还挺有意思的，所谓万事开头难，操作系统已经是将近两年前学的东西了，现在就是很后悔当时没有多读读写写代码，而且非常可惜的是之前没有搞过操作系统比赛，现在想往这个方向转感觉难度还挺大的。ps.希望最后能顺利毕业&#x3D; &#x3D;</p><p>关于具体想做的内容嘛，现在也只是窥得冰山一角，后面如果我觉得对整体认证足够充足的话再试试整理下写成文字吧</p><p>总之现在自己想了想，比较好的一个起步的项目就是mit的6.s081，一个原因是之前上os的时候做过这个实验，虽然当时基本都是遇到不会的就去搜博客，半做半抄搞完的，但是对这个实验的内容感觉还是非常好的，另一个原因就是xv6算是个比较小型的操作系统了，做实验的时候看看代码也挺好的</p><p>另外为什么要用文字记下来呢？其实我本人是不爱记录东西的，之前高中的时候就不爱整理错题本，感觉非常浪费时间。但是现在回头看看，感觉自己用心做了加上用心整理下收获还是挺大的（也挺有纪念意义的<br>另一个原因是去年年末写的15445的lab给我的触动比较大，去年做15445的时候虽然一方面是为了应付作业的报告，但是做的过程感觉还是挺认真的，但是当时没有及时整理，想着最后一起写还能顺便复习一遍，但是最后写的时候才发现记性太差，都忘记了，而且一旦过了刚刚做完的三分钟热度，后面想写点东西感觉还挺难产的。。。感觉还是得做的时候有时间顺手记一下比较好</p><p>另外ucb的cs162好像也不错，有时间的话可以考虑继续开新坑（但是后面大概率没时间了，搞完这个应该就要开始疯狂看论文了，希望下个月能有点idea</p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lab4</title>
    <link href="/2023/02/06/CMU15445-lab4/"/>
    <url>/2023/02/06/CMU15445-lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="Concurrency-Control"><a href="#Concurrency-Control" class="headerlink" title="Concurrency Control"></a>Concurrency Control</h1><p>这个实验主要就是实现事务上的lock manager，从而能够实现并行的query execution，锁方面需要支持的函数就是上shared lock、exclusive lock、upgrade lock以及解锁</p><h2 id="Task1-Lock-Manager-amp-amp-Task2-Deadlock-Prevention"><a href="#Task1-Lock-Manager-amp-amp-Task2-Deadlock-Prevention" class="headerlink" title="Task1 Lock Manager &amp;&amp; Task2 Deadlock Prevention"></a>Task1 Lock Manager &amp;&amp; Task2 Deadlock Prevention</h2><p>这分成了两个任务，但是这两个任务其实都在同一部分的代码里，需要先考虑下怎么写在一起，因为对并行的理解不是很够，之前多线程的代码写的也不多，这部分主要是参考了别的代码和博客搞定的。<br>遇到锁申请的时候首先根据tuple对应的rid把申请放到相应的LockRequest中，后面对某个tuple的所有锁操作都是基于这个队列来完成的。每次上锁的时候大致有三件事，设置growing状态，在rid的等待队列里加入申请的txn id，在txn的锁集合加入rid，这三个操作就是task1的任务。这里还需要实现隔离等级，具体的隔离等级以及相关的措施如下：<br>READ_UNCOMMITED只有在需要时上写锁。<br>READ_COMMITTED要解决脏读的问题，解决方案就是读时上读锁，读完解读锁；写时上写锁，但等到commit时才解写锁；读时上读锁，读完解读锁。这样，永远不会读到未commit的数据，因为上面有写锁。<br>REPEATABLE_READ进一步打造可重复读。同一事务读两次数据的中途不想被其他事务的写干扰，这就需要用到巧妙的二段封锁协议（2PL）了：事务分为两个阶段（不考虑commit&#x2F;abort），上锁阶段(GROWING)只上锁，解锁阶段(SHINKING)只解锁。这样，第二次读取时，前一次读取的读锁一定还在，避免了中途被修改。<br>task2比较难，需要做死锁预防，用到了wound-wait(“young wait for old”)，这个方法主要的思路就是杀死比当前请求年轻的申请，等待更老的申请,这里看博客上说不需要管granted_字段，直接遍历请求队列，执行上面提到的操作就可以。最关键的数据结构一个是上面提到的LockRequest，另一个是txn中的lockset，将这两部分对照起来就能实现这一部分的死锁预防处理。<br>对于读锁来说，因为其可以共存，所以只需要abort掉新事务的写请求<br>而等待操作较为麻烦，主要需要考虑两方面设计，一方面需要使用条件变量协调多线程，也就是等待的时候wait，unlock的时候notify_all，另外一方面，还需要考虑的一点是在等待结束后当前事务有可能已经被abort掉了，所以还需要单独处理。参考的一些做法是用了goto语句，感觉不太合理，但是这里不再继续深究了，就先保留了</p><h2 id="Task3-Concurrent-Query-Execution"><a href="#Task3-Concurrent-Query-Execution" class="headerlink" title="Task3 Concurrent Query Execution"></a>Task3 Concurrent Query Execution</h2><p>在lab3的基础上加读写锁，有的地方不是很理解，比如insert后才得到rid但是这样就没法对表加锁只能对index加锁，但是也通过了测试。另外还要加上index_write_set的操作，用来回滚，只需要在加索引的时候顺便构造一下就可以了。</p><p>对理解有帮助的一篇博客<a href="https://www.inlighting.org/archives/database-concurrency-control">https://www.inlighting.org/archives/database-concurrency-control</a><br>（总结，还是得随手记录一下，不然最后都忘了<br>（以及，有时间的话最好能看看指定教材和ppt，我只是做项目的时候粗略看了下，感觉应该仔细看看<br>这个项目是关于数据库的一个非常好的项目，这个项目的文档非常完善，测试代码非常详细。不仅项目本身自带的一部分测试，还有大量的在线测试，能够找到代码绝大部分的bug与不符合题目要求的地方。为了一些未通过的测试用例去修改代码是一个锻炼代码能力和加深理解的方式。<br>可惜的是在线测试代码没有开源，找bug只能通过简短的提示自己设计用例来测试，比较耗时间。我断断续续做了差不多两个多月的时间，在做project4时还没有全部完成就到了2023年，对2021年的在线测试已经过期了，这部分的代码还只能通过本地的测试。另外比较可惜的一点是我没有看完教材的所有内容和在线的课程，只是面向这个项目学习了一部分知识，如果有时间的话希望能够再去补充学习一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lab3</title>
    <link href="/2023/01/08/CMU15445-lab3/"/>
    <url>/2023/01/08/CMU15445-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="Query-Execution"><a href="#Query-Execution" class="headerlink" title="Query Execution"></a>Query Execution</h1><p>这个实验主要是需要完成一些简单的executor，这里需要简单地了解下迭代器模型中的火山模型，是比较常见的数据库指令运行的模式。这里简单介绍下我的理解：首先输入指令会被解析成一个对应的语法树，对这棵树进行指令相应的操作时，会从根节点逐个节点地向下遍历，遍历到叶子节点时，叶子节点返回下一个值，返回上一个节点，从而一步步回到根节点，不断地重复这个操作，最终得到指令要求的全部数据。理解了这个过程就能大概理解这个实验的主题代码架构。在一个博客里看到这个过程类似于一种协程的概念，生成结果后保留状态等待下一次被唤醒再生成下一个结果，但是我不是很了解这个概念，这里只引用不介绍。<br>另外，这个实验最难的部分其实是对其中预先设定的类的理解是否到位。最好能够先好好阅读各种工具类和相关的测试代码，这样才能充分理解任务的要求和相关的类的功能。</p><h2 id="Task1-Executors"><a href="#Task1-Executors" class="headerlink" title="Task1 Executors"></a>Task1 Executors</h2><p>因为要生成语法树的结构，所以在代码运行的过程中，根据sql语句，会生成相应的abstractexpression类作为树上的节点，代表不同操作的类从这个抽象类中派生出来。具体包含四种expression子类：<br>ConstantValueExpression，ColumnValueExpression，AggregateValueExpression，ComparisonExpression<br>在写代码的时候要充分利用这四种表达式得到语句需要的值从而得到最终返回的结果。<br>update 需要注意的是update的next只能执行一次，不然的话会产生出结果元组，这和原本的语义是不符的<br>join分为两种，nested loop join和hash join，nested loop join比较简单，就是n*m的遍历，找到符合条件的就生成结果就可以，注意循环中的边界条件，以及一边遍历后另一边进入下一个元素的状态切换就可以了。hash join首先需要模仿SimpleAggregationHashTable写个类似的hash类，init的时候先把左边孩子节点的哈希值保存，然后next的时候遍历右孩子节点，找哈希值一样的节点，从而得到结果。需要注意的是，这个必须严格按照这个标准写，时间太长或者太短好像都会导致最后的测试失败。<br>Aggregate也比较难，难点主要在于判断所有数据结构的功能，并且充分利用所有的数据结构。这个主要是需要多读其他部分的代码，有不懂的地方多去找网上的博客。<br>另外要加的一个功能就是index，每次在insert，delete，update的时候都更新相关的索引，这样能够加快查找的速度，这一部分内容可以通过catalog来解决。</p>]]></content>
    
    
    
    <tags>
      
      <tag>“CMU15445&quot;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lab2</title>
    <link href="/2022/12/20/CMU15445-lab2/"/>
    <url>/2022/12/20/CMU15445-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="Extendible-Hashing-Index"><a href="#Extendible-Hashing-Index" class="headerlink" title="Extendible Hashing Index"></a>Extendible Hashing Index</h1><p>这个实验难度比较高，前前后后改了很久很久的bug。。。主要的问题就是对这个可扩展哈希的概念理解的不够，虽然反复看了很多遍但是最后在写的时候在测试时遇到bug才可能知道自己错在哪，有的bug涉及到内存泄漏还很难搞，最后一次提交几乎是重写了一遍，总共在测试网站上提交了80多次，总算通过了全部测试。说起来这个课程好像有配套的教材，有时间可以瞄一眼，感觉很多设计看网站上的指导很模糊&#x3D; &#x3D;<br>关于零长数组可以参考这篇<a href="https://blog.csdn.net/gatieme/article/details/64131322">blog</a><br>因为使用了零长数组，所以如果内存管理出现了问题就会导致某个结构体的某个值可能与预测值不同，这可能就是某一个错误的赋值操作导致的，这个项目难以debug一部分原因也在这里，就算找到了被误改的元素可能也不知道其来源在哪里</p><h2 id="Task1-Page-Layout"><a href="#Task1-Page-Layout" class="headerlink" title="Task1 Page Layout"></a>Task1 Page Layout</h2><p>page分为两种，第一种为Hash Table Directory Page, 第二种为Hash Table Bucket Page，也就是目录页以及具体存tuple的页<br>Bucket page需要实现的部分中主要需要理解occupied和readable成员的含义，occupied的含义是某个位是否被使用过，readable的含义是某个位当前是否存在元素，时间维度上不同，occupied用处不大，感觉可以不用，最后实现的效果就是能够记录每个slot上是否被使用，能够实现增删查<br>Directory Page主要负责的内容是需要根据directory内部保存的索引找到相对应的bucket page，将bucket id映射到page id，同时也保留了local depth和global depth，用于extendible hash增长缩减</p><h2 id="Task2-Hash-Table-Implementation"><a href="#Task2-Hash-Table-Implementation" class="headerlink" title="Task2 Hash Table Implementation"></a>Task2 Hash Table Implementation</h2><p>首先最基础的是Getvalue，这个函数很容易就能实现<br>然后是insert和remove，这两个函数理论上和getvalue同理，但是因为是可扩展哈希，这两个方法还分别涉及到split和merge，相应地也包含directory的grow和shrink，<br>以insert为例，如果是简单的插入的话只需要找到对应的bucketpage，然后用buffer pool manager中实现过的方法就能够实现读取，再对读取到的页进行插入操作即可，但是如果当前要插入的页已经满了的话，因为是extendible hash table，就需要分裂，容易想到，这是一个递归的过程，如果第二次分裂后的结果依然是所有的元素在一个桶中，那么分裂仍然要进行下去。<br>分两种情况，待分裂的桶的localdepth等于globaldepth，这种情况下需要directory double。double后先默认最高位取反的index与原本的index指向同一个桶，然后将需要分裂的桶对应的index修改指向新创建的桶，同时维护相关的global depth和local depth。最后还需要对桶里的元素rehash，重新映射到两个桶中。等于的情况下实现起来的一个好处就是如果深度相等，那么只需要处理这个桶和新的桶两个桶的关系，其他的保留即可。小于的情况下是多对一的情况，需要多对一重新映射<br>如果小于，那么直接找对应的split image。这里需要注意的是怎么去找split image，大概的思路就是local depth对应的位取反的做一组，不取反的做一组，这样划分的两组才能够符合分裂的逻辑<br>需要注意的是，如果一次分裂之后不满足条件，需要递归地去分裂这个桶，所以可以把递归程序写到一个单独的函数中用来递归，在满足条件的时候从insert引用<br>merge也是一样的道理，需要递归地去操作，但是这里最开始有个错误卡了很久，最后查到是对概念理解出现了问题导致代码的原理出错了，就是关于merge bucket的index应该取哪一位的问题。<br>相对来说，目录的grow和shrink就非常简单，只需要在split和merge的时候注意一下即可</p><h2 id="Task3-Concurrency-Control"><a href="#Task3-Concurrency-Control" class="headerlink" title="Task3 Concurrency Control"></a>Task3 Concurrency Control</h2><p>这里有两种锁，lock和latch，其中lock对hash table锁，我理解是一个比较大的层面上的锁，是用来锁directory的，latch则是对每个bucket page的锁，每次读写的时候考虑下是否会改变相应的数据结构加上相应的锁就可以了，加锁之后记得退出要解锁，每个分支都注意到就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lab1</title>
    <link href="/2022/12/03/CMU15445-lab1/"/>
    <url>/2022/12/03/CMU15445-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="buffer-pool-manager"><a href="#buffer-pool-manager" class="headerlink" title="buffer pool manager"></a>buffer pool manager</h1><p>这个实验比较简单，讲的是在底层的页级别的读写是怎么做的，一共有三个实验：LRU Replacement Policy, Buffer Pool Manager Instance, Parrallel Buffer Pool Manager，难度大概是2&gt;1&gt;3<br>在开始之前首先需要想清楚这个实验要做的是什么，第一个任务实现了一个Replacer，这个Replacer票选出哪一个内存中的块可以被换出，第二个任务就是在此基础上进一步实现，第三个任务与多线程相关。。</p><h2 id="Task1-LRU-Replacement-Policy"><a href="#Task1-LRU-Replacement-Policy" class="headerlink" title="Task1 LRU Replacement Policy"></a>Task1 LRU Replacement Policy</h2><p>这个任务可以主要工作就是实现一个LRU，双端链表+哈希表就可以，相关的方法也就是LRU的接口的另一种表达</p><h2 id="Task2-Buffer-Pool-Manager-Instance"><a href="#Task2-Buffer-Pool-Manager-Instance" class="headerlink" title="Task2 Buffer Pool Manager Instance"></a>Task2 Buffer Pool Manager Instance</h2><p>这个任务比较有难度，六个接口，这些接口的功能我怀疑有些测试也没有完全测试到。<br>课程网站上有一段话说的比较好，这里摘抄一下：</p><blockquote><p>Note: Pin and Unpin within the contexts of the LRUReplacer and the BufferPoolManagerInstance have inverse meanings. Within the context of the LRUReplacer, pinning a page implies that we shouldn’t evict the page because it is in use. This means we should remove it from the LRUReplacer. On the other hand, pinning a page in the BufferPoolManagerInstance implies that we want to use a page, and that it should not be removed from the buffer pool.</p></blockquote><p>在LRU中，pin意味着某个页在使用，所以不能把他再留在Replacer中，因为Replacer中的是留着等待换出的，在BufferPoolManagerInstance中，pin的意思是在使用中，所以这个页还不能被移出Pool<br>这里的难点一方面是page数据结构里面的变量比较多，需要注意设置的变量比较多，需要注意点，另外一方面是需要注意这个数据结构，page_table_  std::unordered_map&lt;page_id_t, frame_id_t&gt;,从page_id映射到frame_id，具体两者的关系可以看图<br><img src="/../picture/buffer_pool_manager.png" alt="page-&gt;frame"></p><h2 id="Task3-Parallel-Buffer-Pool-Manager"><a href="#Task3-Parallel-Buffer-Pool-Manager" class="headerlink" title="Task3 Parallel Buffer Pool Manager"></a>Task3 Parallel Buffer Pool Manager</h2><p>这个就比较简单了，调用下之前实现了的接口就可以了，主要需要写的代码就是新加入的页应该加入哪个buffer pool，这个按照教程写就可以了（这里我感觉我写的错了但是还是通过了全部测试，很奇怪</p>]]></content>
    
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lab0</title>
    <link href="/2022/12/03/CMU15445-lab0/"/>
    <url>/2022/12/03/CMU15445-lab0/</url>
    
    <content type="html"><![CDATA[<h2 id="先从环境配置讲起"><a href="#先从环境配置讲起" class="headerlink" title="先从环境配置讲起"></a>先从环境配置讲起</h2><p>按照项目github地址或是课程指导书地址，配置工程文件。这里我选择的是用docker来配置项目。我是在windows上写的，每次写代码之前先启动docker desktop，配置的时候有共享的文件夹，所以可以在windows下的vscode里写代码，然后在命令行切到docker容器里make &amp; test</p><h2 id="vscode的显示问题"><a href="#vscode的显示问题" class="headerlink" title="vscode的显示问题"></a>vscode的显示问题</h2><p>vscode有可能有两个可能出问题的地方，一是windows环境里没有c++的库文件，这个问题可以通过下载mingw解决，另一个是代码提示可能出问题要手动在设置里把c++默认版本调到11以上</p><h2 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h2><p>略（这个项目用到的也就push pull）</p><h2 id="c-基础"><a href="#c-基础" class="headerlink" title="c++基础"></a>c++基础</h2><p>还在恶补c++ primer。。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>数据库教学整体结构可以参考这幅图，实验内容大致是从底向上但是不完全相同<img src="/../picture/hierarchy.png" alt="结构"></p><h2 id="帮助很大的博客"><a href="#帮助很大的博客" class="headerlink" title="帮助很大的博客"></a>帮助很大的博客</h2><p><a href="https://blog.csdn.net/freedom1523646952/article/details/123056958">https://blog.csdn.net/freedom1523646952/article/details/123056958</a><br><a href="https://blog.csdn.net/twentyonepilots/article/details/120868216">https://blog.csdn.net/twentyonepilots/article/details/120868216</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first blog</title>
    <link href="/2022/12/02/first-blog/"/>
    <url>/2022/12/02/first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="first-blog"><a href="#first-blog" class="headerlink" title="first blog!"></a>first blog!</h1><p>第一次尝试写博客。。主要是为了记录下最近在做的数据库实验，方便以后回来查找<br>后面有机会的话可能会把看的论文和写的项目顺便更新上来？</p>]]></content>
    
    
    
    <tags>
      
      <tag>casual</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
